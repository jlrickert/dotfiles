#!/usr/bin/env bash

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"

# Load environmental variables
PROJECT_ROOT="$(cd "${SCRIPT_DIR}" && git rev-parse --show-toplevel)"
. "${PROJECT_ROOT}/lib/env.sh"
. "${PROJECT_ROOT}/lib/func.sh"

cd "${PROJECT_ROOT}"

######################### Tab Completion Context ########################
# Check if we are in a tab completion context
if test -n "${COMP_LINE}"; then
	# Parse the command line for the subcommand and preceding arguments
	# COMP_LINE is the full command line being completed
	# We want the word *after* the script name as the subcommand
	# And words *after* the subcommand as arguments for completion
	script_name="$(basename "${BASH_SOURCE[0]}")"
	# Use awk to find the index of the script name and get the next word
	script_index=$(echo "${COMP_LINE}" | awk -v name="${script_name}" '{ for(i=1; i<=NF; i++) if ($i == name) print i; }')
	cmd_index=$((script_index + 1))
	arg_start_index=$((cmd_index + 1))

	cmd="$(echo "${COMP_LINE}" | awk -v idx="${cmd_index}" '{ print $idx }')"
	pre="$(echo "${COMP_LINE}" | awk -v idx="${arg_start_index}" '{ for(i=idx; i<=NF; i++) printf $i" "; print "" }')"

	# Debugging completion (optional)
	# echo "COMP_LINE: ${COMP_LINE}" >&2
	# echo "script_name: ${script_name}" >&2
	# echo "script_index: ${script_index}" >&2
	# echo "cmd: ${cmd}" >&2
	# echo "pre: ${pre}" >&2

	case "${cmd}" in
	shell)
		# The shell subcommand doesn't take arguments for completion
		# We can potentially complete with nothing or the list of subcommands
		available_subcommands="shell build" # List all top-level subcommands here

		for sub in ${available_subcommands}; do
			# If 'cmd' is empty (completing the first word) or matches the start of 'sub'
			if [ -z "${cmd}" ] || [[ "${sub}" =~ ^${cmd} ]]; then
				echo "${sub}"
			fi
		done
		exit 0 # Exit after providing completions
		;;

	build)
		# The build subcommand doesn't take arguments for completion
		# We can potentially complete with nothing or the list of subcommands
		available_subcommands="shell build" # List all top-level subcommands here

		for sub in ${available_subcommands}; do
			# If 'cmd' is empty (completing the first word) or matches the start of 'sub'
			if [ -z "${cmd}" ] || [[ "${sub}" =~ ^${cmd} ]]; then
				echo "${sub}"
			fi
		done
		exit 0 # Exit after providing completions
		;;
	docker)
		# Delegate completion to the standard docker completion function
		# This assumes the standard bash completion for docker is available
		if type _docker &>/dev/null; then
			_docker
		fi
		exit 0
		;;
	*)
		# Default completion: list available subcommands
		# Filter by the 'cmd' string if it exists (when completing the subcommand itself)
		# Or filter by 'pre' if completing after the subcommand (though this case is handled above)
		available_subcommands="shell build docker" # List all top-level subcommands here

		for sub in ${available_subcommands}; do
			# If 'cmd' is empty (completing the first word) or matches the start of 'sub'
			if [ -z "${cmd}" ] || [[ "${sub}" =~ ^${cmd} ]]; then
				echo "${sub}"
			fi
		done
		exit 0 # Exit after providing completions
		;;
	esac
fi
###################### End Tab Completion Context #######################

set -o errexit  # exit if non-zero status code is returned
set -o nounset  # exit if undefined variable is used
set -o pipefail # exit if no-zero status code is returned in a pipeline

###
## Command Handling
###

# Get the subcommand
# Default to 'shell' if no argument is provided
subcommand="${1:-shell}"

# Shift the subcommand off the arguments list if it was explicitly provided
if [ "$#" -gt 0 ] && [ "$1" != "shell" ]; then
	shift
fi

case "${subcommand}" in
shell)
	log_message INFO "Running 'shell' subcommand."

	# Check if Docker is installed.
	if ! command -v docker &>/dev/null; then
		log_message ERROR "Docker is not installed. Please install Docker."
		exit 1
	fi

	IMAGE_NAME="dotfiles"

	# Check if the image exists, and set it up if it doesn't.
	if ! docker image inspect "${IMAGE_NAME}" &>/dev/null; then
		log_message INFO "Docker image '${IMAGE_NAME}' not found. Building..."
		./bin/docker-build
	else
		log_message INFO "Docker image '${IMAGE_NAME}' found."
	fi

	ensure_environment

	log_message INFO "Starting Docker container..."
	docker run -it \
		--mount "type=bind,src=${PROJECT_ROOT},dst=/root/.config/dotfiles" \
		--mount "type=bind,src=${DOTFILES_DATA_HOME},dst=/root/.local/share/dotfiles" \
		--mount "type=bind,src=${DOTFILES_STATE_HOME},dst=/root/.local/state/dotfiles" \
		--mount "type=bind,src=${DOTFILES_CACHE_HOME},dst=/root/.cache/dotfiles" \
		"${IMAGE_NAME}" \
		"$@" # Pass remaining arguments to the container entrypoint
	;;

build)
	log_message INFO "Running 'build' subcommand."
	# Check if Docker is installed.
	if ! command -v docker &>/dev/null; then
		log_message ERROR "Docker is not installed. Please install Docker."
		exit 1
	fi
	log_message INFO "Attempting to build Docker image: ${IMAGE_NAME} using Dockerfile ${DOCKERFILE_PATH}"
	if docker build -t "${IMAGE_NAME}" -f "${DOCKERFILE_PATH}" "."; then
		log_message SUCCESS "Docker image built successfully: ${IMAGE_NAME}"
	else
		log_message ERROR "Docker image build failed for ${IMAGE_NAME}"
		exit 1
	fi
	;;

docker)
	log_message INFO "Running 'docker' subcommand."
	# Check if Docker is installed.
	if ! command -v docker &>/dev/null; then
		log_message ERROR "Docker is not installed. Please install Docker."
		exit 1
	fi
	log_message INFO "Executing docker command with arguments: \`$*\`"
	# Execute the docker command with the remaining arguments
	docker run -it \
		--mount "type=bind,src=${PWD},dst=/root/.config/dotfiles" \
		--workdir "/root" \
		ubuntu \
		"$@"
	;;
*)
	# Default case for unknown subcommands
	log_message ERROR "Unknown subcommand: \`${subcommand}\`" >&2
	log_message INFO "Usage: $(basename "$0") [subcommand] [args...]"
	log_message INFO "Available subcommands: shell (default), build"
	exit 1
	;;
esac
