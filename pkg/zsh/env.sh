if [ -z "${ZSH_VERSION+set}" ] || [ -z "$ZSH_VERSION" ]; then
	return 0
fi

## Stop if non interactive
case "$-" in
*i*) ;;
*) return 0 ;;
esac

# shellcheck disable=SC1094
source "${PACKAGE_PATH}/lib/compdef"
# shellcheck disable=SC1094
source "${PACKAGE_PATH}/lib/compgen"
# shellcheck disable=SC1094
source "${PACKAGE_PATH}/lib/complete"
# shellcheck disable=SC1094
source "${PACKAGE_PATH}/lib/_bash_complete"

# https://zdharma-continuum.github.io/Zsh-100-Commits-Club/Zsh-Plugin-Standard.html
# 0="${ZERO:-${${0:#$ZSH_ARGZERO}:-${(%):-%N}}}"
# 0="${${(M)0:#/*}:-$PWD/$0}"
# shellcheck disable=SC1094
source "${PACKAGE_PATH}/lib/zsh-vi-mode.zsh"

function load_completions() {
	local executable_path
	# Iterate over each executable file found directly in the DOTFILES_BIN directory.
	# Using find with -print0 and a while read loop is the safest way to handle
	# filenames containing spaces or special characters, unlike parsing `ls` output.
	# Find executable files (-type f) directly in the directory (-maxdepth 1).
	# Use -perm /u+x to check for owner execute permission, which is portable
	# across GNU (Linux) and BSD (macOS) find implementations.
	find "${DOTFILES_BIN}" -maxdepth 1 -type f -print0 | while IFS= read -r -d '' executable_path; do
		# Extract the basename of the executable file. This is the command name.
		local executable_name=$(basename "${executable_path}")

		# Set up bash completion for the command named "${executable_name}".
		# The -C option specifies that the command itself
		# ("${executable_name}") should be executed to generate the completion
		# list.
		complete -C "${executable_name}" "${executable_name}"
	done

	# Check if the installed packages directory exists
	if ! [ -d "${DOTFILES_STATE_HOME}/pkg" ]; then
		return 0
	fi

	local installed_packages_root="${DOTFILES_STATE_HOME}/pkg"
	local package_entry=

	# Find directories directly under ${DOTFILES_STATE_HOME}/pkg (these are the
	# package symlinks/dirs) Use find with -print0 for safe handling of names
	# with spaces or special characters
	find "${installed_packages_root}" -mindepth 1 -maxdepth 1 -print0 | while IFS= read -r -d '' package_entry; do
		if [ ! -d "${package_entry}/bin" ]; then
			continue
		fi

		for i in ${package_entry}/bin/*; do
			local executable_name="$(basename $i)"
			complete -C "$i" "$i"
		done
		# find "${package_entry}" 
		# Check if the entry resolves to an actual directory (handles symlinks and real dirs)
		# if [ -d "${package_entry}" ]; then
		# 	# Construct the path to the 'bin' directory within this package entry
		# 	local pkg_bin_dir="${package_entry}/bin"
		#
		# 	# Check if the 'bin' directory exists and is a directory.
		# 	# Suppress error messages from the test command if path is invalid or doesn't exist.
		# 	if [ -d "${pkg_bin_dir}" ] 2>/dev/null; then
		#
		# 		local executable_path
		# 		# Now find executable files directly inside this 'bin' directory
		# 		# Use find here for robustness and -executable flag, and -print0 for safety
		# 		find "${pkg_bin_dir}" -maxdepth 1 | while IFS= read -r -d '' executable_path; do
		# 			# executable_path is the full path to the executable, e.g., /path/to/pkg/bin/my_command
		#
		# 			# Get the basename of the executable
		# 			local executable_name=$(basename "${executable_path}")
		#
		# 			# Attempt to set completion using the executable name for -C and basename for command name.
		# 			# This assumes the executable itself, when called by name (which must be in PATH),
		# 			# acts as the completion generator.
		# 			# Suppress potential errors from 'complete' itself if it fails for a specific binary.
		# 			complete -C "${executable_name}" "${executable_name}"
		#
		# 		done # End while loop for executables
		# 	fi    # End check for bin directory existence
		# fi     # End check if package_entry resolves to a directory
	done # End while loop for package entries

	# No explicit output to stdout is generated by this function now.
}

autoload -Uz compinit
compinit

load_completions

have starship && eval "$(starship init zsh)"
have ssh-agen && eval "$(ssh-agen)" &>/dev/null

bindkey '^k' up-history
bindkey '^j' down-history

if have brew; then
	HOMEBREW_PREFIX="$(brew --prefix)"
	if [[ -r "${HOMEBREW_PREFIX}/etc/profile.d/bash_completion.sh" ]]; then
		# shellcheck disable=SC1091
		source "${HOMEBREW_PREFIX}/etc/profile.d/bash_completion.sh"
	else
		for COMPLETION in "${HOMEBREW_PREFIX}/etc/bash_completion.d/"*; do
			# shellcheck disable=SC1090
			[[ -r "${COMPLETION}" ]] && source "${COMPLETION}"
		done
	fi
fi
