#!/usr/bin/env bash

SCRIPT_DIR="$(dirname "$(readlink -f "$0")")"

# Load environmental variables
PROJECT_ROOT="$(cd "${SCRIPT_DIR}" && git rev-parse --show-toplevel)"

export NOCOLOR=
[[ -t 1 ]] || NOCOLOR=y
export GOLD='[38;2;184;138;0m'
export RED='[38;2;255;0;0m'
export GREY='[38;2;100;100;100m'
export CYAN='[38;2;0;255;255m'
export GREEN='[38;2;0;255;0m'
export RESET='[0m'

if [[ -n "${NOCOLOR}" ]]; then
	GOLD=
	RED=
	GREY=
	CYAN=
	GREEN=
	RESET=
fi

# export DOTFILES_VERSION="$(cd "${SCRIPT_DIR}" && git rev-parse --abbrev-ref HEAD)"

# This is where the user specific config should live that is private. This is
# safe to sync between systems
export DOTFILES_DATA_HOME="${HOME}/.local/share/dotfiles"

# Dotfiles specific state for the machine. This is not safe to sync between
# systems.
export DOTFILES_STATE_HOME="${HOME}/.local/state/dotfiles"

# This is where the publish shared configuration lives.  This is where
export DOTFILES_CONFIG_HOME="${HOME}/.config/dotfiles"

# This is where cache data lives. Safe to remove at anytime.
export DOTFILES_CACHE_HOME="${HOME}/.cache/dotfiles"

# Sets and exports the DOTFILES_LOG_FILE variable.
# Defaults to a 'log' file within the DOTFILES_STATE directory if not already set.
export DOTFILES_LOG_FILE="${DOTFILES_STATE_HOME}/log"

# --- Ensure PROJECT_ROOT/bin is in PATH ---
# This must be done here in env.sh because it's sourced early, before functions
# like log_message are available. Use standard shell commands.
export DOTFILES_BIN="${PROJECT_ROOT}/bin"

export XDG_CACHE_HOME="${HOME}/.cache"
export XDG_CONFIG_HOME="${HOME}/.config"
export XDG_DATA_HOME="${HOME}/.local/share"
export XDG_STATE_HOME="${HOME}/.local/state"
export XDG_DESKTOP_DIR="${HOME}/Desktop"
export XDG_DOCUMENTS_DIR="${HOME}/Documents"
export XDG_DOWNLOAD_DIR="${HOME}/Downloads"
export XDG_MUSIC_DIR="${HOME}/Music"
export XDG_PICTURES_DIR="${HOME}/Pictures"
export XDG_PUBLICSHARE_DIR="${HOME}/Public"
export XDG_TEMPLATES_DIR="${HOME}/Templates"
export XDG_VIDEOS_DIR="${HOME}/Videos"
export DESKTOP="${XDG_DESKTOP_DIR}"
export DOCUMENTS="${XDG_DOCUMENTS_DIR}"
export DOWNLOAD="${XDG_DOWNLOAD_DIR}"
export MUSIC_DIR="${XDG_MUSIC_DIR}"
export PICTURES="${XDG_PICTURES_DIR}"
export PUBLIC="${XDG_PUBLICSHARE_DIR}"
export TEMPLATES="${XDG_TEMPLATES_DIR}"
export VIDEOS="${XDG_VIDEOS_DIR}"

function source_if() {
	# shellcheck disable=SC1090
	[[ -r "$1" ]] && source "$1"
}

function have() {
	type "$1" &>/dev/null
}

# append to path if it exists
function pathappend() {
	for arg in "$@"; do
		test -d "$arg" || continue
		PATH=${PATH//":$arg:"/:} # remove all occuences of `:$arg:` from the PATH
		PATH=${PATH/#"$arg:"/}   # remove `"$arg:"` from the the beginning of the string
		PATH=${PATH/%":$arg"/}   # remove `":$arg` from the end of the string
		export PATH="${PATH:+"$PATH:"}$arg"
	done
}

# Prepend to path if it exists
#
# Remember, last arg will be first in path. Precedence comes to the item that
# comes at the head of the list. Appended paths are pruned if they do not
# exist.
function pathprepend() {
	for arg in "$@"; do
		test -d "$arg" || continue
		PATH=${PATH//:"$arg:"/:}
		PATH=${PATH/#"$arg:"/}
		PATH=${PATH/%":$arg"/}
		export PATH="$arg${PATH:+":${PATH}"}"
	done
}

function load_packages() {
	if ! [ -d "${DOTFILES_STATE_HOME}/pkg" ]; then
		return 0
	fi
	# Find directories directly under ${HOME}/.local/state/pkg, output their basenames null-separated
	find "${DOTFILES_STATE_HOME}/pkg" -mindepth 1 -maxdepth 1 -type d -print0 | while IFS= read -r -d '' full_path; do
		# pkg_name is now just the directory name (e.g., "some-package")

		# Construct the paths based on PROJECT_ROOT and package name
		local pkg_env_file="${PROJECT_ROOT}/${pkg_name}/env.sh"
		local pkg_bin_path="${PROJECT_ROOT}/${pkg_name}/bin"

		# Source the environment file if it exists
		if [ -f "${pkg_env_file}" ]; then
			# shellcheck disable=SC1090 # Source command with dynamic path
			. "${pkg_env_file}"
		fi

		# Prepend package bin to path if the directory exists. It should check
		# if the constructed pkg_bin_path exists.
		if [ -d "${pkg_bin_path}" ]; then
			echo $pkg_bin_path
			pathappend "${pkg_bin_path}"
		fi
	done
}

# remember last arg will be first in path. Precedence comes to the item that
# comes at the head of the list. Appended paths are pruned if they do not
# exist.
pathprepend \
	"${HOME}/.local/bin" \
	"${HOME}/bin" \
	"${DOTFILES_BIN}"

pathappend \
	/usr/local/bin \
	/usr/local/sbin \
	/usr/local/games \
	/usr/games \
	/usr/sbin \
	/usr/bin \
	/snap/bin \
	/sbin \
	/bin

if have /opt/homebrew/bin/brew; then
	# shellcheck disable=SC1090
	source <(/opt/homebrew/bin/brew shellenv)

	python_bin="$(find /Users/jlrickert/Library/Python -name "bin")"
	[[ -d "${python_bin}" ]] && pathappend "${python_bin}"

	pathappend /opt/homebrew/opt/mysql-client/bin
fi

load_packages
